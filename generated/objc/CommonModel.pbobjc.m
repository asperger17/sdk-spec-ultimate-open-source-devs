// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common_model.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "CommonModel.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(GPBStringValue);
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(IndexMapping);

#pragma mark - CommonModelRoot

@implementation CommonModelRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - CommonModelRoot_FileDescriptor

static GPBFileDescriptor *CommonModelRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.elarian.hera.proto"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum CustomerNumberProvider

GPBEnumDescriptor *CustomerNumberProvider_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CustomerNumberProviderUnspecified\000Custom"
        "erNumberProviderFacebook\000CustomerNumberP"
        "roviderCellular\000CustomerNumberProviderTe"
        "legram\000CustomerNumberProviderApp\000Custome"
        "rNumberProviderEmail\000";
    static const int32_t values[] = {
        CustomerNumberProvider_CustomerNumberProviderUnspecified,
        CustomerNumberProvider_CustomerNumberProviderFacebook,
        CustomerNumberProvider_CustomerNumberProviderCellular,
        CustomerNumberProvider_CustomerNumberProviderTelegram,
        CustomerNumberProvider_CustomerNumberProviderApp,
        CustomerNumberProvider_CustomerNumberProviderEmail,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CustomerNumberProvider)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CustomerNumberProvider_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CustomerNumberProvider_IsValidValue(int32_t value__) {
  switch (value__) {
    case CustomerNumberProvider_CustomerNumberProviderUnspecified:
    case CustomerNumberProvider_CustomerNumberProviderFacebook:
    case CustomerNumberProvider_CustomerNumberProviderCellular:
    case CustomerNumberProvider_CustomerNumberProviderTelegram:
    case CustomerNumberProvider_CustomerNumberProviderApp:
    case CustomerNumberProvider_CustomerNumberProviderEmail:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChannelNumberProvider

GPBEnumDescriptor *ChannelNumberProvider_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ChannelNumberProviderUnspecified\000Channel"
        "NumberProviderAt\000ChannelNumberProviderTw"
        "ilio\000ChannelNumberProviderMailgun\000Channe"
        "lNumberProviderFacebook\000ChannelNumberPro"
        "viderTelegram\000";
    static const int32_t values[] = {
        ChannelNumberProvider_ChannelNumberProviderUnspecified,
        ChannelNumberProvider_ChannelNumberProviderAt,
        ChannelNumberProvider_ChannelNumberProviderTwilio,
        ChannelNumberProvider_ChannelNumberProviderMailgun,
        ChannelNumberProvider_ChannelNumberProviderFacebook,
        ChannelNumberProvider_ChannelNumberProviderTelegram,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChannelNumberProvider)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChannelNumberProvider_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChannelNumberProvider_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChannelNumberProvider_ChannelNumberProviderUnspecified:
    case ChannelNumberProvider_ChannelNumberProviderAt:
    case ChannelNumberProvider_ChannelNumberProviderTwilio:
    case ChannelNumberProvider_ChannelNumberProviderMailgun:
    case ChannelNumberProvider_ChannelNumberProviderFacebook:
    case ChannelNumberProvider_ChannelNumberProviderTelegram:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MediaType

GPBEnumDescriptor *MediaType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MediaTypeUnspecified\000MediaTypeImage\000Medi"
        "aTypeAudio\000MediaTypeVideo\000MediaTypeDocum"
        "ent\000MediaTypeVoice\000MediaTypeSticker\000Medi"
        "aTypeContact\000";
    static const int32_t values[] = {
        MediaType_MediaTypeUnspecified,
        MediaType_MediaTypeImage,
        MediaType_MediaTypeAudio,
        MediaType_MediaTypeVideo,
        MediaType_MediaTypeDocument,
        MediaType_MediaTypeVoice,
        MediaType_MediaTypeSticker,
        MediaType_MediaTypeContact,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MediaType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MediaType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MediaType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MediaType_MediaTypeUnspecified:
    case MediaType_MediaTypeImage:
    case MediaType_MediaTypeAudio:
    case MediaType_MediaTypeVideo:
    case MediaType_MediaTypeDocument:
    case MediaType_MediaTypeVoice:
    case MediaType_MediaTypeSticker:
    case MediaType_MediaTypeContact:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CustomerEventDirection

GPBEnumDescriptor *CustomerEventDirection_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CustomerEventDirectionUnspecified\000Custom"
        "erEventDirectionInbound\000CustomerEventDir"
        "ectionOutbound\000";
    static const int32_t values[] = {
        CustomerEventDirection_CustomerEventDirectionUnspecified,
        CustomerEventDirection_CustomerEventDirectionInbound,
        CustomerEventDirection_CustomerEventDirectionOutbound,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CustomerEventDirection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CustomerEventDirection_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CustomerEventDirection_IsValidValue(int32_t value__) {
  switch (value__) {
    case CustomerEventDirection_CustomerEventDirectionUnspecified:
    case CustomerEventDirection_CustomerEventDirectionInbound:
    case CustomerEventDirection_CustomerEventDirectionOutbound:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CustomerRequestOrigin

GPBEnumDescriptor *CustomerRequestOrigin_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CustomerRequestOriginUnspecified\000Custome"
        "rRequestOriginApiRequest\000CustomerRequest"
        "OriginCustomerTag\000CustomerRequestOriginR"
        "eplay\000";
    static const int32_t values[] = {
        CustomerRequestOrigin_CustomerRequestOriginUnspecified,
        CustomerRequestOrigin_CustomerRequestOriginApiRequest,
        CustomerRequestOrigin_CustomerRequestOriginCustomerTag,
        CustomerRequestOrigin_CustomerRequestOriginReplay,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CustomerRequestOrigin)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CustomerRequestOrigin_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CustomerRequestOrigin_IsValidValue(int32_t value__) {
  switch (value__) {
    case CustomerRequestOrigin_CustomerRequestOriginUnspecified:
    case CustomerRequestOrigin_CustomerRequestOriginApiRequest:
    case CustomerRequestOrigin_CustomerRequestOriginCustomerTag:
    case CustomerRequestOrigin_CustomerRequestOriginReplay:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DataMapValue

@implementation DataMapValue

@dynamic valueOneOfCase;
@dynamic stringVal;
@dynamic bytesVal;

typedef struct DataMapValue__storage_ {
  uint32_t _has_storage_[2];
  NSString *stringVal;
  NSData *bytesVal;
} DataMapValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stringVal",
        .dataTypeSpecific.clazz = Nil,
        .number = DataMapValue_FieldNumber_StringVal,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DataMapValue__storage_, stringVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bytesVal",
        .dataTypeSpecific.clazz = Nil,
        .number = DataMapValue_FieldNumber_BytesVal,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(DataMapValue__storage_, bytesVal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DataMapValue class]
                                     rootClass:[CommonModelRoot class]
                                          file:CommonModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DataMapValue__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "value",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void DataMapValue_ClearValueOneOfCase(DataMapValue *message) {
  GPBDescriptor *descriptor = [DataMapValue descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Cash

@implementation Cash

@dynamic currencyCode;
@dynamic amount;

typedef struct Cash__storage_ {
  uint32_t _has_storage_[1];
  NSString *currencyCode;
  double amount;
} Cash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "currencyCode",
        .dataTypeSpecific.clazz = Nil,
        .number = Cash_FieldNumber_CurrencyCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Cash__storage_, currencyCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = Cash_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Cash__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Cash class]
                                     rootClass:[CommonModelRoot class]
                                          file:CommonModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Cash__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IndexMapping

@implementation IndexMapping

@dynamic key;
@dynamic hasValue, value;

typedef struct IndexMapping__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  GPBStringValue *value;
} IndexMapping__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.clazz = Nil,
        .number = IndexMapping_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IndexMapping__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = IndexMapping_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IndexMapping__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IndexMapping class]
                                     rootClass:[CommonModelRoot class]
                                          file:CommonModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IndexMapping__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CustomerIndex

@implementation CustomerIndex

@dynamic hasMapping, mapping;
@dynamic hasExpiresAt, expiresAt;

typedef struct CustomerIndex__storage_ {
  uint32_t _has_storage_[1];
  IndexMapping *mapping;
  GPBTimestamp *expiresAt;
} CustomerIndex__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mapping",
        .dataTypeSpecific.clazz = GPBObjCClass(IndexMapping),
        .number = CustomerIndex_FieldNumber_Mapping,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CustomerIndex__storage_, mapping),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "expiresAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = CustomerIndex_FieldNumber_ExpiresAt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CustomerIndex__storage_, expiresAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CustomerIndex class]
                                     rootClass:[CommonModelRoot class]
                                          file:CommonModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CustomerIndex__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AppConnectionProps

@implementation AppConnectionProps

@dynamic connectionId;
@dynamic hasConnectionTime, connectionTime;
@dynamic hasIpAddress, ipAddress;
@dynamic simplexMode;

typedef struct AppConnectionProps__storage_ {
  uint32_t _has_storage_[1];
  NSString *connectionId;
  GPBTimestamp *connectionTime;
  GPBStringValue *ipAddress;
} AppConnectionProps__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "connectionId",
        .dataTypeSpecific.clazz = Nil,
        .number = AppConnectionProps_FieldNumber_ConnectionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppConnectionProps__storage_, connectionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connectionTime",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = AppConnectionProps_FieldNumber_ConnectionTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppConnectionProps__storage_, connectionTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ipAddress",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = AppConnectionProps_FieldNumber_IpAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AppConnectionProps__storage_, ipAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "simplexMode",
        .dataTypeSpecific.clazz = Nil,
        .number = AppConnectionProps_FieldNumber_SimplexMode,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppConnectionProps class]
                                     rootClass:[CommonModelRoot class]
                                          file:CommonModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppConnectionProps__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CustomerNumber

@implementation CustomerNumber

@dynamic provider;
@dynamic number;
@dynamic hasPartition, partition;

typedef struct CustomerNumber__storage_ {
  uint32_t _has_storage_[1];
  CustomerNumberProvider provider;
  NSString *number;
  GPBStringValue *partition;
} CustomerNumber__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "provider",
        .dataTypeSpecific.enumDescFunc = CustomerNumberProvider_EnumDescriptor,
        .number = CustomerNumber_FieldNumber_Provider,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CustomerNumber__storage_, provider),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "number",
        .dataTypeSpecific.clazz = Nil,
        .number = CustomerNumber_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CustomerNumber__storage_, number),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "partition",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBStringValue),
        .number = CustomerNumber_FieldNumber_Partition,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CustomerNumber__storage_, partition),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CustomerNumber class]
                                     rootClass:[CommonModelRoot class]
                                          file:CommonModelRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CustomerNumber__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CustomerNumber_Provider_RawValue(CustomerNumber *message) {
  GPBDescriptor *descriptor = [CustomerNumber descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CustomerNumber_FieldNumber_Provider];
  return GPBGetMessageRawEnumField(message, field);
}

void SetCustomerNumber_Provider_RawValue(CustomerNumber *message, int32_t value) {
  GPBDescriptor *descriptor = [CustomerNumber descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CustomerNumber_FieldNumber_Provider];
  GPBSetMessageRawEnumField(message, field, value);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
